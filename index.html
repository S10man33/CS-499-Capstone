<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Darrell Lindsey – Computer Science ePortfolio</title>
    <link rel="stylesheet" href="Style.css" />
</head>
<body>
    <header>
        <div class="header-content">
            <h1>Darrell Lindsey</h1>
            <h2>Computer Science ePortfolio</h2>
        </div>
    </header>

    <main>
        <section id="self-assessment">
            <h2>Professional Self-Assessment</h2>
            <p>
                Completing the Computer Science program at Southern New Hampshire University has been a transformative experience that not only deepened my technical expertise but also reshaped my professional identity and long-term career goals. Entering the program with over 25 years of experience in hardware repair and technical support, I brought a strong foundation in troubleshooting and process-driven environments. However, the curriculum challenged me to evolve into a full-stack software developer capable of designing scalable, maintainable, and secure applications. Through rigorous coursework, collaborative projects, and iterative enhancement of my ePortfolio, I developed proficiency in object-oriented programming, cloud database integration, modular architecture, and test-driven development. The capstone experience, in particular, allowed me to synthesize these skills into a cohesive Android inventory application that reflects both technical depth and user-centered design. This portfolio now serves as a professional showcase of my ability to solve complex problems, communicate effectively with diverse audiences, and deliver production-ready software aligned with industry standards.
            </p>

            <p>
                <strong>Outcome 1: Collaborative Environments</strong><br />
                Throughout the program, I employed strategies for building collaborative environments by participating in peer code reviews, group discussions, and iterative feedback loops. In my final project, I integrated feedback from instructors and peers to improve modularity and test coverage. I also used GitHub for version control and issue tracking, which enabled asynchronous collaboration and decision-making across diverse audiences.
            </p>

            <p>
                <strong>Outcome 2: Professional Communication</strong><br />
                I designed and delivered professional-quality written and visual communications through enhancement summaries, structured documentation, and this ePortfolio. My code review video demonstrates oral communication skills, while my artifact narratives reflect technical clarity and audience awareness. I adapted my communication style to suit both technical stakeholders and academic reviewers, ensuring coherence and professionalism.
            </p>

            <p>
                <strong>Outcome 3: Algorithmic Solutions</strong><br />
                My Binary Search Tree artifact showcases my ability to design and evaluate computing solutions using algorithmic principles. I implemented recursive traversal, comparator injection, and performance tuning to manage trade-offs between readability and efficiency. These enhancements reflect a deep understanding of algorithmic design and problem-solving standards.
            </p>

            <p>
                <strong>Outcome 4: Innovative Techniques and Tools</strong><br />
                I demonstrated innovation by transitioning from local SQLite to Firebase Realtime Database, integrating Kotlin coroutines for asynchronous execution, and applying dependency injection for testability. My Inventory Management App reflects industry-specific goals such as scalability, maintainability, and cloud integration. These tools and techniques were selected to deliver real-world value.
            </p>

            <p>
                <strong>Outcome 5: Security Mindset</strong><br />
                I developed a security mindset by implementing input validation and structured error handling in my FirebaseRepository.kt artifact. These measures help prevent malformed data from reaching the database and ensure that operations fail gracefully when unexpected conditions arise. While I have not yet implemented retry logic, I have outlined plans to add it in future iterations to improve offline resilience and data consistency. I also intend to incorporate role-based access control and field-level validation to further mitigate risks such as unauthorized access and data leakage. These enhancements reflect a proactive approach to identifying and addressing potential vulnerabilities in cloud-connected applications.
            </p>

            <p>
                The artifacts in this portfolio reflect my growth across these domains. Each one demonstrates a different facet of my skill set: software design and engineering, algorithms and data structures, and cloud-based database integration. Together, they form a cohesive narrative of my evolution as a developer—one who values clarity, scalability, and maintainability.
            </p>

            <p>
                This self-assessment serves as both an introduction to my technical capabilities and a reflection of the values I bring to software development. I am confident that the skills and principles I’ve cultivated throughout this program will make me a valuable contributor to any development team.
            </p>
        </section>

        <section id="video">
            <h2>Code Review Video</h2>
            <div class="video-container">
                <iframe width="640" height="360" src="https://www.youtube.com/embed/DaeN2BN8lM8"
                        title="CodeReviewLindsey" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                        allowfullscreen></iframe>
            </div>

            <p>
                This video walks through my original and enhanced artifacts, explaining my design decisions and how they demonstrate growth in software engineering, algorithms, and databases.
            </p>
        </section>

        <section id="artifacts">
            <h2>Enhanced Artifacts</h2>

            <article>
                <h3>Software Design and Engineering</h3>
                <p>
                    <strong>Enhancements:</strong> Migrated from Java to Kotlin, modularized activities and validation logic, integrated Firebase Authentication and Firestore, added item-level editing and deletion.<br />
                    <strong>Skills Demonstrated:</strong> Refactoring legacy code, object-oriented design, cloud integration, UI synchronization.<br />
                    <strong>Course Outcomes:</strong> Applied software engineering principles, designed maintainable and scalable systems.
                </p>
                <p>
                    <strong>Narrative:</strong><br />
                    This Kotlin-based mobile inventory application was originally developed in Java during earlier coursework and later refactored to Kotlin to align with modern Android development practices. I selected this artifact because it reflects my evolution as a software engineer, particularly in transitioning from procedural code to a modular, object-oriented architecture. The migration process involved decomposing monolithic logic into reusable components, centralizing input validation, and integrating Firebase Authentication and Firestore for secure, cloud-based data management.<br /><br />

                    One of the most impactful enhancements was the introduction of item-level editing and deletion, which required careful synchronization between the UI and Firestore. I implemented asynchronous listeners to ensure real-time updates and consistent state management across views. Additionally, I created a centralized validation utility to enforce input rules across multiple fragments and composables, improving maintainability and reducing redundancy.<br /><br />

                    Challenges included resolving Gradle build errors related to dependency mismatches and designing a flexible validation system that could be extended without modifying core logic. Through iterative code reviews, I refined my approach to UI modularization and improved testability using MockK and JUnit. This artifact demonstrates my ability to refactor legacy code, apply scalable design principles, and integrate cloud services effectively. It aligns with course outcomes in software engineering, cloud integration, and structured communication.<br /><br />

                    Here’s a sample of the actual validation logic used across authentication and item management flows:<br />
                    <img src="Snippet1.png" alt="InputValidator Kotlin Code Screenshot" style="max-width:100%; height:auto; border:1px solid #ccc; margin-top:10px; margin-bottom:10px;" /><br />

                    This object-oriented approach allows consistent validation across composables and view models, promoting separation of concerns and simplifying unit testing. It also supports future enhancements such as password strength indicators or localized error messages.
                </p>

                <p>
                    <a href="https://github.com/s10man33/cs-499-capstone/tree/main/Enhancement%20One" target="_blank">
                        🔗 View Enhancement One Files on GitHub
                    </a>
                </p>

            </article>

            <article>
                <h3>Algorithms and Data Structures</h3>
                <p>
                    <strong>Enhancements:</strong> Added comparator injection for multi-field sorting, optimized recursive traversal, expanded unit test coverage, ensured coroutine compatibility.<br />
                    <strong>Skills Demonstrated:</strong> Algorithmic design, performance tuning, abstraction, test-driven development.<br />
                    <strong>Course Outcomes:</strong> Designed computing solutions using algorithmic principles, implemented scalable and efficient data structures.
                </p>
                <p>
                    <strong>Narrative:</strong><br />
                    This custom binary search tree (BST) implementation originated in earlier coursework and was significantly enhanced during CS-499 to support multi-field sorting, coroutine compatibility, and deeper unit test coverage. I selected this artifact because it demonstrates my growth in algorithmic design and performance tuning, especially in adapting recursive structures to modern Kotlin paradigms.<br /><br />

                    One of the most impactful enhancements was the injection of custom comparators, allowing the BST to sort nodes based on multiple fields such as name, quantity, or timestamp. This abstraction decouples sorting logic from the data structure itself, making the tree reusable across different contexts. I also optimized recursive traversal methods to reduce stack overhead and ensure compatibility with Kotlin coroutines, enabling non-blocking operations in UI-bound environments.<br /><br />

                    Challenges included adapting recursive logic to Android’s threading model, ensuring type-safe comparator injection, and maintaining traversal efficiency without sacrificing readability. I used sealed classes and extension functions to encapsulate traversal strategies, and MockK-based unit tests to validate edge cases and concurrency behavior. Feedback from code reviews led to cleaner abstraction boundaries and more robust test coverage.<br /><br />

                    This artifact aligns with course outcomes in algorithmic design, performance analysis, and test-driven development. It reflects my ability to design scalable data structures, inject flexible sorting logic, and write maintainable, coroutine-friendly algorithms.<br /><br />

                    <img src="Snippet2.png" alt="BST Comparator Injection Code Screenshot" style="max-width:100%; height:auto; border:1px solid #ccc; margin-top:10px; margin-bottom:10px;" /><br />

                    This design supports multi-field sorting without modifying core tree logic, reinforcing separation of concerns and enabling reuse across modules. It also lays the foundation for coroutine-based traversal and future enhancements like search filtering or range queries.
                </p>

                <p>
                    <a href="https://github.com/s10man33/cs-499-capstone/tree/main/Enhancement%20Two" target="_blank">
                        🔗 View Enhancement Two Files on GitHub
                    </a>
                </p>

            </article>

            <article>
                <h3>Databases</h3>
                <p>
                    <strong>Enhancements:</strong> Replaced SQLite with Firebase Realtime Database, added structured error handling, implemented input validation, modularized repository interface.<br />
                    <strong>Skills Demonstrated:</strong> Cloud database integration, asynchronous programming, secure CRUD operations, testability design.<br />
                    <strong>Course Outcomes:</strong> Applied innovative database techniques, designed resilient and secure data layers, communicated technical decisions through clean code.
                </p>
                <p>
                    <strong>Narrative:</strong><br />
                    This Kotlin class manages real-time CRUD operations using Firebase Realtime Database. I selected it to demonstrate my growth in cloud database integration, asynchronous programming, and error resilience. Originally built with SQLite, the data layer was refactored to use Firebase Realtime Database to support real-time sync and cloud scalability. This transition required rethinking data flow, error handling, and testability.<br /><br />

                    Key enhancements included structured error handling using a sealed `OperationResult` type, input validation through centralized utilities, and modularization of the repository interface to decouple Firebase logic from UI components. I designed the repository to expose suspend functions for coroutine compatibility, allowing seamless integration with view models and lifecycle-aware scopes.<br /><br />

                    One of the most challenging aspects was abstracting Firebase callbacks into coroutine-friendly suspend functions while maintaining type safety and error traceability. I used `try-catch` blocks and custom result wrappers to ensure predictable behavior across success and failure states. Feedback from code reviews helped me refine naming conventions, improve documentation, and isolate testable logic from platform dependencies.<br /><br />

                    This artifact aligns with course outcomes in database design, secure CRUD operations, and maintainable software engineering. It reflects my ability to apply innovative database techniques, design resilient data layers, and communicate technical decisions through clean, modular code.<br /><br />

                    <img src="Snippet3.png" alt="Firebase Registration Code Screenshot" style="max-width:100%; height:auto; border:1px solid #ccc; margin-top:10px; margin-bottom:10px;" /><br />

                    The screenshot above shows the `registerUser` method, where Firebase Authentication and Firestore operations are wrapped in suspend functions with structured error handling and input validation. This design supports future enhancements such as retry logic, offline caching, and mockable test injection.
                </p>

                <p>
                    <a href="https://github.com/s10man33/cs-499-capstone/tree/main/Enhancement%20Three" target="_blank">
                        🔗 View Enhancement Three Files on GitHub
                    </a>
                </p>

            </article>
        </section>

        <section id="contact">
            <h2>Contact & Links</h2>
            <p>
                GitHub: <a href="https://github.com/S10man33" target="_blank">github.com/S10man33</a><br />
                Email: s10man33@gmail.com
            </p>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Darrell Lindsey</p>
    </footer>
</body>
</html>





